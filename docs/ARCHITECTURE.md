# System Architecture Explanation

This explanation summarizes how the Finetune ERP platform is composed and how data flows between the backend, frontend, and operational services that support repair shop workflows.

```mermaid
flowchart LR
    subgraph Client
        UI[React Frontend]
    end
    subgraph Django Apps
        Accounts[Accounts & Auth]
        Bookings[Bookings]
        Attendance[Attendance]
        Inventory[Inventory & Spares]
        Invoicing[Invoicing]
        Activity[Activity Logs]
    end
    subgraph Services
        Notifications[Notification Service]
        Commands[Scheduled Management Commands]
    end
    subgraph Data Stores
        DB[(PostgreSQL / SQLite)]
        Media[(Static & Media Storage)]
    end
    UI -- RTK Query / REST --> Accounts
    UI -- Repair Flows --> Bookings
    Accounts --> DB
    Bookings --> DB
    Attendance --> DB
    Inventory --> DB
    Invoicing --> DB
    Activity --> DB
    Notifications -- Email/SMS --> External Channels
    Commands -- Summaries --> Attendance
    Django Apps --> Media
```

## Backend layers

- **Domain apps** – Django apps under `accounts`, `bookings`, `inventory`, `marketing`, `attendance`, `invoicing`, `activity`, and `store` expose REST endpoints through DRF routers. The URLs listed in [API_ROUTES.md](reference/API_ROUTES.md) reflect each registered router or path.
- **Settings & configuration** – Environment variables outlined in [ENVIRONMENT_KEYS.md](reference/ENVIRONMENT_KEYS.md) control secrets, notification channels, and feature toggles. The project defaults to SQLite for local development and switches to PostgreSQL when `DATABASE_URL` points at a managed database.

> [!NOTE]
> Keep router registrations centralized—`scripts/generate_references.py` depends on DRF conventions to keep the reference file accurate.

### Core Backend Modules

- **accounts** – Custom user model with role-based access control and JWT authentication
- **store** – Store catalog, branch locations, and branch head assignment management
- **attendance** – Employee check-in/check-out, shift management, approvals, and attendance reports
- **bookings** – Customer repair request intake and scheduling
- **inventory** – Parts, accessories, and serialized device tracking
- **invoicing** – Invoice generation and payment recording for completed repairs
- **activity** – Audit trail and activity logging for compliance
- **marketing** – Public-facing marketing forms and lead capture

### Request Lifecycle

1. Client authenticates with JWT token (`Authorization: Bearer <token>`)
2. DRF views and routers dispatch requests to application logic
3. Serializers validate incoming data and interact with Django models
4. Responses use Spring-style pagination when listing resources
5. Model changes trigger signals for downstream processing

### Signals & Middleware

- **Signal handlers**: `accounts.signals.auto_unassign_branch_head_on_user_change` automatically removes inactive branch heads and clears their store assignments
- **Middleware stack**: CORS headers, session management, CSRF protection, and WhiteNoise for static file serving
- **Authentication middleware**: JWT token validation and user context injection

## Frontend structure

- **Routing** – `src/App.jsx` wires marketing pages, customer-authenticated flows, and admin dashboards with React Router 7. Layout components (`PublicLayout`, `FocusLayout`, `DashboardLayout`) manage responsive breakpoints and share theming.
- **State management** – Redux Toolkit Query (`src/api/erpApi.js`) handles API requests, automatic token refresh, and cache invalidation. Hooks generated by the slice power dashboards, booking forms, and inventory tools.
- **Design system** – Tailwind utility classes and CSS variables in `src/index.css` define colors and spacing. Components must rely on the layout shells to avoid competing layout authorities.

### Routing Details

- **Public routes**: `/`, `/teamlogin`, `/signup`, `/about/`, `/contact/`, `/locate/`, `/terms-and-conditions/`, `/schedule-call`, and e-commerce routes (`/shop`, `/product/:id`, etc.). The `/login` route is reserved for public customer login.
- **Protected routes**: `/dashboard` and all sub-routes require a valid `token` cookie for access
- **Role-gated routes**: Within `/dashboard`, administrative routes like `/users`, `/stores`, and `/settings` require `role` of `system_admin`

### State Management Details

Redux Toolkit slices manage UI state across the application:

| Slice   | Responsibility                      |
| ------- | ----------------------------------- |
| `auth`  | Authentication tokens and user info |
| `user`  | User list & pagination              |
| `store` | Store records & pagination          |
| `cart`  | E-commerce cart state               |

Asynchronous operations use `createAsyncThunk` backed by a shared `fetchBaseQuery` that handles automatic token attachment and refresh. Components dispatch follow-up queries after mutations to refresh data.

### Error Handling

- API errors and success states surface as toast notifications to users
- No global error boundary or automatic retry/backoff mechanism is currently implemented
- Network failures are handled at the component level with user-facing error messages

## Background services

- **Notifications** – `NotificationService` sends transactional emails and SMS using templates under `finetune-ERP-backend-New/templates/`.
- **Attendance rollups** – Management commands such as `attendance_autoclose` finalize prior-day attendance and payroll adjustments.
- **Integrations** – Marketing and booking submissions trigger downstream alerts via the notification service and `BOOKING_NOTIFICATION_CHANNELS` configuration.

## Data flow & integration points

1. A customer or internal user triggers an action in the frontend.
2. The frontend sends an authenticated request to the Django API using the RTK Query client.
3. The API validates the request, persists state changes, and triggers any required notifications or management commands.
4. Background jobs (management commands or scheduled scripts) finalize attendance, send reminders, or notify staff as needed.
5. The frontend polls or subscribes to updated state, rendering the latest results.

## Security and observability

- JSON Web Tokens secure dashboard APIs. Refresh/verify routes are published via [API_ROUTES.md](reference/API_ROUTES.md).
- CSP, CORS, and HTTPS settings derive from environment keys to keep deployment-specific overrides in configuration rather than code.
- Audit trails are stored through the `activity` app and exposed under `/api/logs/` for compliance.

## Related Documentation

- [API Routes Reference](reference/API_ROUTES.md) – Auto-generated API endpoint documentation
- [Environment Keys Reference](reference/ENVIRONMENT_KEYS.md) – Configuration variables and secrets
- [Frontend Routes Reference](reference/FRONTEND_ROUTES.md) – React Router route definitions
- [Developer Guide](DEVELOPER_GUIDE.md) – Daily development workflows
- [Getting Started](GETTING_STARTED.md) – Initial setup and onboarding
- [Security Guide](SECURITY.md) – Security practices for backend and frontend
- [Testing Guide](TESTING.md) – Testing strategies and test execution
- [Deployment Guide](DEPLOYMENT.md) – Deployment procedures and environment configuration
